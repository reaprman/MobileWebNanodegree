{"version":3,"sources":["dbhelper.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","database","review_store","storename","dbPromise","idb","open","upgradeDb","oldVersion","createObjectStore","keypath","keyValStore","createIndex","connection","navigator","mozConnection","webkitConnection","networkStatus","DBHelper","this","value","callback","id","fetchURL","DATABASE_URL","fetch","then","response","json","restaurants","console","log","err","error","concat","fetchRestaurants","restaurant","find","r","cuisine","results","filter","cuisine_type","neighborhood","neighborhoods","map","v","uniqueNeighborhoods","indexOf","cuisines","uniqueCuisines","marker","L","latlng","lat","lng","title","name","alt","url","urlForRestaurant","addTo","newMap","db","transaction","objectStore","getAll","reviews","result","offlineFlag","forEach","review","saveNewReview","networkReconnectAddReview","onLine","networkReconnect","favStatus","is_favorite","put","data","updateRestaurantByID","postUrl","method","tx","store","complete","reviewURL","DATABASE_URL_REVIEWS","body","JSON","stringify","addUpdateReviewIDB","rating","comment","restaurant_id","comments","createdAt","Date","now","tempId","getTime","get","port","addEventListener","updateConnectionStatus"],"mappings":"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","file":"dbhelper.js","sourcesContent":["const database = 'restaurant-db';\r\nconst review_store = 'reviews';\r\nconst storename = 'restaurants';\r\nconst dbPromise = idb.open(database, 1, upgradeDb => {\r\n  switch (upgradeDb.oldVersion) {\r\n    case 0:\r\n      upgradeDb.createObjectStore(storename, {keypath: 'id'});\r\n      let keyValStore = upgradeDb.createObjectStore(review_store, { keypath: 'id' });\r\n      keyValStore.createIndex('restaurant_id', 'restaurant_id');\r\n  }\r\n});\r\n\r\nlet connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;\r\nlet networkStatus = true;\r\n\r\n\r\n/**\r\n * Common database helper functions.\r\n */\r\nclass DBHelper {\r\n\r\n  /**\r\n   * Database URL.\r\n   * Change this to restaurants.json file location on your server.\r\n   */\r\n  static get DATABASE_URL() {\r\n    const port = 1337 // Change this to your server port\r\n    return `http://localhost:${port}/restaurants`;\r\n  }\r\n\r\n  static get DATABASE_URL_REVIEWS() {\r\n    const port = 1337\r\n    return `http://localhost:${port}/reviews/`;\r\n  }\r\n  \r\n  /**\r\n   * Fetch all restaurants.\r\n   */\r\n  static fetchRestaurants(callback, id) {\r\n    /* let xhr = new XMLHttpRequest();\r\n    xhr.open('GET', DBHelper.DATABASE_URL);\r\n    xhr.onload = () => {\r\n      if (xhr.status === 200) { // Got a success response from server!\r\n        const json = JSON.parse(xhr.responseText);\r\n        const restaurants = json.restaurants;\r\n        callback(null, restaurants);\r\n      } else { // Oops!. Got an error from server.\r\n        const error = (`Request failed. Returned status of ${xhr.status}`);\r\n        callback(error, null);\r\n      }\r\n    };\r\n    xhr.send(); \r\n    */\r\n    let fetchURL = DBHelper.DATABASE_URL;\r\n\r\n    if (!id) {\r\n      fetchURL = DBHelper.DATABASE_URL;\r\n    } else {\r\n      fetchURL = DBHelper.DATABASE_URL + '/' + id;\r\n    }\r\n\r\n      fetch(fetchURL).then(response => {\r\n      response.json().then(restaurants => {\r\n      console.log(\"restaurants JSON: \", restaurants); // added from Project supplied webinar to troubleshoot 10th image not displaying\r\n      callback(null, restaurants);\r\n      });\r\n    }).catch(err => {\r\n    const error = (`Request failed. Returned ${err}`);\r\n    callback(error, null);\r\n  });\r\n}\r\n\r\n  /**\r\n   * Fetch a restaurant by its ID.\r\n   */\r\n  static fetchRestaurantById(id, callback) {\r\n    // fetch all restaurants with proper error handling.\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        console.log(`callback type: ${typeof callback}`);\r\n        callback(error, null);\r\n      } else {\r\n        const restaurant = restaurants.find(r => r.id == id);\r\n        if (restaurant) { // Got the restaurant\r\n          callback(null, restaurant);\r\n        } else { // Restaurant does not exist in the database\r\n          callback('Restaurant does not exist', null);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a cuisine type with proper error handling.\r\n   */\r\n  static fetchRestaurantByCuisine(callback, cuisine) {\r\n    // Fetch all restaurants  with proper error handling\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Filter restaurants to have only given cuisine type\r\n        const results = restaurants.filter(r => r.cuisine_type == cuisine);\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a neighborhood with proper error handling.\r\n   */\r\n  static fetchRestaurantByNeighborhood(callback, neighborhood) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Filter restaurants to have only given neighborhood\r\n        const results = restaurants.filter(r => r.neighborhood == neighborhood);\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a cuisine and a neighborhood with proper error handling.\r\n   */\r\n  static fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood, callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        //console.log(typeof callback);\r\n        callback(error, null);\r\n      } else {\r\n        let results = restaurants\r\n        if (cuisine != 'all') { // filter by cuisine\r\n          results = results.filter(r => r.cuisine_type == cuisine);\r\n        }\r\n        if (neighborhood != 'all') { // filter by neighborhood\r\n          results = results.filter(r => r.neighborhood == neighborhood);\r\n        }\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all neighborhoods with proper error handling.\r\n   */\r\n  static fetchNeighborhoods(callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Get all neighborhoods from all restaurants\r\n        const neighborhoods = restaurants.map((v, i) => restaurants[i].neighborhood)\r\n        // Remove duplicates from neighborhoods\r\n        const uniqueNeighborhoods = neighborhoods.filter((v, i) => neighborhoods.indexOf(v) == i)\r\n        callback(null, uniqueNeighborhoods);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all cuisines with proper error handling.\r\n   */\r\n  static fetchCuisines(callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Get all cuisines from all restaurants\r\n        const cuisines = restaurants.map((v, i) => restaurants[i].cuisine_type)\r\n        // Remove duplicates from cuisines\r\n        const uniqueCuisines = cuisines.filter((v, i) => cuisines.indexOf(v) == i)\r\n        callback(null, uniqueCuisines);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Restaurant page URL.\r\n   */\r\n  static urlForRestaurant(restaurant) {\r\n    return (`./restaurant.html?id=${restaurant.id}`);\r\n  }\r\n\r\n  /**\r\n   * Restaurant image URL.\r\n   * Change needed for Rest Server as extension is no longer supplied\r\n   */\r\n  static imageUrlForRestaurant(restaurant) {\r\n    //change due to database not having photograph value for every entry\r\n    return (`/img/${restaurant.id}.jpg`);\r\n  }\r\n\r\n  /**\r\n   * Map marker for a restaurant.\r\n   */\r\n   static mapMarkerForRestaurant(restaurant, map) {\r\n    // https://leafletjs.com/reference-1.3.0.html#marker  \r\n    const marker = new L.marker([restaurant.latlng.lat, restaurant.latlng.lng],\r\n      {title: restaurant.name,\r\n      alt: restaurant.name,\r\n      url: DBHelper.urlForRestaurant(restaurant)\r\n      })\r\n      marker.addTo(newMap);\r\n    return marker;\r\n  } \r\n  /* static mapMarkerForRestaurant(restaurant, map) {\r\n    const marker = new google.maps.Marker({\r\n      position: restaurant.latlng,\r\n      title: restaurant.name,\r\n      url: DBHelper.urlForRestaurant(restaurant),\r\n      map: map,\r\n      animation: google.maps.Animation.DROP}\r\n    );\r\n    return marker;\r\n  } */\r\n\r\n  /**\r\n   * \r\n   */\r\n  static checkConnection(){\r\n    return (networkStatus === true) ?true :false;\r\n  }\r\n\r\n  static networkReconnectAddReview(){\r\n    dbPromise.then(db => {\r\n      return db.transaction(review_store)\r\n      .objectStore(review_store).getAll();\r\n    }).then(results => {\r\n      let reviews = results.filter(result => result.offlineFlag == true);\r\n      reviews.forEach(review => {\r\n      delete review.offlineFlag;\r\n        DBHelper.saveNewReview(review, (error, result) =>{\r\n          if(error){\r\n            callback(error, null);\r\n            return;\r\n          }\r\n          callback(null, result);\r\n        });\r\n      })\r\n    }).catch(err => {\r\n      callback(err,null);\r\n    })\r\n  }\r\n\r\n  /**\r\n   * \r\n   */\r\n  static networkReconnect(){\r\n    DBHelper.networkReconnectAddReview();\r\n  }\r\n\r\n  /**\r\n   * \r\n   */\r\n  static updateConnectionStatus() {\r\n    if(!navigator.onLine){\r\n      networkStatus = false;\r\n      console.log(`Connection has been lost: ${networkStatus}`);\r\n    } else {\r\n      networkStatus = true;\r\n      console.log(`Connection reestablished: ${networkStatus}`);\r\n      //check for pending updates need more code under here\r\n      DBHelper.networkReconnect();\r\n    }\r\n  }\r\n\r\n  static updateRestaurantIDB(restaurant, callback) {\r\n    //check if offline if so add offline flag to restaurant\r\n    const favStatus = restaurant.is_favorite;\r\n    dbPromise.then(db => {\r\n      return db.transaction(storename, 'readwrite')\r\n      .objectStore(storename).put(restaurant, restaurant.id);\r\n    }).then(data => {\r\n      console.log(`Successfull change of favorite for ${data}`);\r\n      DBHelper.updateRestaurantByID(data, favStatus, (error, result) => {\r\n        if(error){\r\n          callback(error,null);\r\n          return;\r\n        }\r\n        callback(null, result);\r\n      })\r\n    }).catch(err => {\r\n      console.log(`Error updating favorite for: ${err}`);\r\n      callback(err, null);\r\n    })\r\n  }\r\n\r\n  static updateRestaurantByID(id, favStatus, callback) {\r\n    const postUrl = `${DBHelper.DATABASE_URL}/${id}/?is_favorite=${favStatus}`;\r\n    fetch(postUrl, {method: 'post'})\r\n    .then(response => {\r\n      response.json().then(result => {\r\n      console.log(`Success changing favorite on server: ${result}`);\r\n      callback(null, result);\r\n      })\r\n    }).catch(err => {\r\n      const error = `Error updating favorite status: ${err}`;\r\n      console.log(error);\r\n      callback(error, null);\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Add new and Update old review\r\n   */\r\n  static addUpdateReviewIDB(review) {\r\n    dbPromise.then(db => {\r\n      console.log('adding review to idb cache');\r\n      const tx = db.transaction(review_store, 'readwrite');\r\n      const store = tx.objectStore(review_store);\r\n      store.put(review, review.id)\r\n      return tx.complete;\r\n    }).then(function() {\r\n      console.log(`successfully added ${review} `)\r\n    }).catch(error=> {\r\n      console.log(`Error adding review to idb cache: ${error}`);\r\n    })\r\n  }\r\n\r\n  /**\r\n   * \r\n   */\r\n  static saveNewReview(review, callback){\r\n    const reviewURL = DBHelper.DATABASE_URL_REVIEWS;\r\n    fetch(reviewURL, {\r\n      method: 'post',\r\n      body: JSON.stringify(review)\r\n    }).then(response => {\r\n      response.json().then(results => {\r\n        //call to function to add or update db\r\n        DBHelper.addUpdateReviewIDB(results);\r\n        callback(null,results);\r\n      });\r\n    }).catch(err => {\r\n      const error = `Submission to server failed: ${err}`;\r\n      callback(error,null);\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Save Review \r\n   */\r\n  static saveReview(id, name, rating, comment,callback) {\r\n    const review = {\r\n      restaurant_id: id,\r\n      name: name,\r\n      rating: rating,\r\n      comments: comment,\r\n      createdAt: Date.now()\r\n    }\r\n    //if connection submit to server else post in idb with flag set for offline\r\n    //DBHelper.checkConnection();\r\n    if(networkStatus == false){\r\n      //add flag for offline\r\n      const tempId = new Date().getTime();\r\n      review.id = tempId;\r\n      review.offlineFlag = true;\r\n      //add review to idb\r\n      DBHelper.addUpdateReviewIDB(review);\r\n      return;\r\n    }\r\n    DBHelper.saveNewReview(review, (error, result) => {\r\n      if(error){\r\n        callback(error, null);\r\n        return;\r\n      }\r\n      callback(null, result);\r\n    });\r\n  }\r\n  /**\r\n   * Fetch reviews by id for resource management\r\n   */\r\n  static fetchReviewByRestaurantId(id, callback){\r\n      const reviewURL = `${DBHelper.DATABASE_URL_REVIEWS}?restaurant_id=${id}`;\r\n      console.log(reviewURL);\r\n      fetch(reviewURL).then(response => {\r\n        response.json().then(reviews => {\r\n          /*if(!reviews){\r\n            callback(error,null);\r\n          } else{\r\n            //deal with reviews that are found...add to idb\r\n            reviews.forEach(review => {\r\n              DBHelper.addUpdateReviewIDB(review);\r\n            });  \r\n          } */\r\n          callback(null, reviews);\r\n        }).catch(err => {\r\n          console.log(`Review request failed: Returned ${err}`);\r\n          /* dbPromise.then(db => {\r\n            return db.transaction(review_store).objectStore(review_store)\r\n            .index('restaurant_id').getAll(id);\r\n          }).then(reviews => {\r\n            callback(null,reviews);\r\n          }) */\r\n        })\r\n      });\r\n  }\r\n}\r\n//add event listener for connection change from mozilla.org\r\nconnection.addEventListener('change', DBHelper.updateConnectionStatus);\r\n\r\n"]}