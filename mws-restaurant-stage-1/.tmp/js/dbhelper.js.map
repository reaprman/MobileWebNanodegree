{"version":3,"sources":["dbhelper.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","review_database","review_store","dbReviews","idb","open","upgradeDb","oldVersion","keyValStore","createObjectStore","keypath","createIndex","connection","navigator","mozConnection","webkitConnection","type","effectiveType","networkStatus","DBHelper","this","value","callback","id","fetchURL","DATABASE_URL","fetch","then","response","json","restaurants","console","log","err","error","concat","fetchRestaurants","restaurant","find","r","cuisine","results","filter","cuisine_type","neighborhood","neighborhoods","map","v","uniqueNeighborhoods","indexOf","cuisines","uniqueCuisines","marker","L","latlng","lat","lng","title","name","alt","url","urlForRestaurant","addTo","newMap","db","transaction","objectStore","getAll","reviews","result","offlineFlag","forEach","review","saveNewReview","networkReconnectAddReview","networkReconnect","put","reviewURL","DATABASE_URL_REVIEWS","method","body","JSON","stringify","addUpdateReviewIDB","rating","comment","restaurant_id","comments","createdAt","Date","now","tempId","getTime","final","get","port","addEventListener","updateConnectionStatus"],"mappings":"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","file":"dbhelper.js","sourcesContent":["const review_database = 'review-db';\nconst review_store = 'reviews';\nconst dbReviews = idb.open(review_database, 1, upgradeDb => {\n  switch (upgradeDb.oldVersion) {\n    case 0:\n      let keyValStore = upgradeDb.createObjectStore(review_store, { keypath: 'id' });\n      keyValStore.createIndex('restaurant_id', 'restaurant_id');\n  }\n});\n\nlet connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;\nlet type = connection.effectiveType;\nlet networkStatus = true;\n\n\n/**\n * Common database helper functions.\n */\nclass DBHelper {\n\n  /**\n   * Database URL.\n   * Change this to restaurants.json file location on your server.\n   */\n  static get DATABASE_URL() {\n    const port = 1337 // Change this to your server port\n    return `http://localhost:${port}/restaurants`;\n  }\n\n  static get DATABASE_URL_REVIEWS() {\n    const port = 1337\n    return `http://localhost:${port}/reviews/`;\n  }\n  \n  /**\n   * Fetch all restaurants.\n   */\n  static fetchRestaurants(callback, id) {\n    /* let xhr = new XMLHttpRequest();\n    xhr.open('GET', DBHelper.DATABASE_URL);\n    xhr.onload = () => {\n      if (xhr.status === 200) { // Got a success response from server!\n        const json = JSON.parse(xhr.responseText);\n        const restaurants = json.restaurants;\n        callback(null, restaurants);\n      } else { // Oops!. Got an error from server.\n        const error = (`Request failed. Returned status of ${xhr.status}`);\n        callback(error, null);\n      }\n    };\n    xhr.send(); \n    */\n    let fetchURL = DBHelper.DATABASE_URL;\n\n    if (!id) {\n      fetchURL = DBHelper.DATABASE_URL;\n    } else {\n      fetchURL = DBHelper.DATABASE_URL + '/' + id;\n    }\n\n      fetch(fetchURL).then(response => {\n      response.json().then(restaurants => {\n      console.log(\"restaurants JSON: \", restaurants); // added from Project supplied webinar to troubleshoot 10th image not displaying\n      callback(null, restaurants);\n      });\n    }).catch(err => {\n    const error = (`Request failed. Returned ${err}`);\n    callback(error, null);\n  });\n}\n\n  /**\n   * Fetch a restaurant by its ID.\n   */\n  static fetchRestaurantById(id, callback) {\n    // fetch all restaurants with proper error handling.\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        console.log(`callback type: ${typeof callback}`);\n        callback(error, null);\n      } else {\n        const restaurant = restaurants.find(r => r.id == id);\n        if (restaurant) { // Got the restaurant\n          callback(null, restaurant);\n        } else { // Restaurant does not exist in the database\n          callback('Restaurant does not exist', null);\n        }\n      }\n    });\n  }\n\n  /**\n   * Fetch restaurants by a cuisine type with proper error handling.\n   */\n  static fetchRestaurantByCuisine(callback, cuisine) {\n    // Fetch all restaurants  with proper error handling\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        // Filter restaurants to have only given cuisine type\n        const results = restaurants.filter(r => r.cuisine_type == cuisine);\n        callback(null, results);\n      }\n    });\n  }\n\n  /**\n   * Fetch restaurants by a neighborhood with proper error handling.\n   */\n  static fetchRestaurantByNeighborhood(callback, neighborhood) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        // Filter restaurants to have only given neighborhood\n        const results = restaurants.filter(r => r.neighborhood == neighborhood);\n        callback(null, results);\n      }\n    });\n  }\n\n  /**\n   * Fetch restaurants by a cuisine and a neighborhood with proper error handling.\n   */\n  static fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood, callback) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        //console.log(typeof callback);\n        callback(error, null);\n      } else {\n        let results = restaurants\n        if (cuisine != 'all') { // filter by cuisine\n          results = results.filter(r => r.cuisine_type == cuisine);\n        }\n        if (neighborhood != 'all') { // filter by neighborhood\n          results = results.filter(r => r.neighborhood == neighborhood);\n        }\n        callback(null, results);\n      }\n    });\n  }\n\n  /**\n   * Fetch all neighborhoods with proper error handling.\n   */\n  static fetchNeighborhoods(callback) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        // Get all neighborhoods from all restaurants\n        const neighborhoods = restaurants.map((v, i) => restaurants[i].neighborhood)\n        // Remove duplicates from neighborhoods\n        const uniqueNeighborhoods = neighborhoods.filter((v, i) => neighborhoods.indexOf(v) == i)\n        callback(null, uniqueNeighborhoods);\n      }\n    });\n  }\n\n  /**\n   * Fetch all cuisines with proper error handling.\n   */\n  static fetchCuisines(callback) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        // Get all cuisines from all restaurants\n        const cuisines = restaurants.map((v, i) => restaurants[i].cuisine_type)\n        // Remove duplicates from cuisines\n        const uniqueCuisines = cuisines.filter((v, i) => cuisines.indexOf(v) == i)\n        callback(null, uniqueCuisines);\n      }\n    });\n  }\n\n  /**\n   * Restaurant page URL.\n   */\n  static urlForRestaurant(restaurant) {\n    return (`./restaurant.html?id=${restaurant.id}`);\n  }\n\n  /**\n   * Restaurant image URL.\n   * Change needed for Rest Server as extension is no longer supplied\n   */\n  static imageUrlForRestaurant(restaurant) {\n    //change due to database not having photograph value for every entry\n    return (`/img/${restaurant.id}.jpg`);\n  }\n\n  /**\n   * Map marker for a restaurant.\n   */\n   static mapMarkerForRestaurant(restaurant, map) {\n    // https://leafletjs.com/reference-1.3.0.html#marker  \n    const marker = new L.marker([restaurant.latlng.lat, restaurant.latlng.lng],\n      {title: restaurant.name,\n      alt: restaurant.name,\n      url: DBHelper.urlForRestaurant(restaurant)\n      })\n      marker.addTo(newMap);\n    return marker;\n  } \n  /* static mapMarkerForRestaurant(restaurant, map) {\n    const marker = new google.maps.Marker({\n      position: restaurant.latlng,\n      title: restaurant.name,\n      url: DBHelper.urlForRestaurant(restaurant),\n      map: map,\n      animation: google.maps.Animation.DROP}\n    );\n    return marker;\n  } */\n\n  /**\n   * \n   */\n  static checkConnection(){\n    return (networkStatus === true) ?true :false;\n  }\n\n  static networkReconnectAddReview(){\n    dbReviews.then(db => {\n      return db.transaction(review_store)\n      .objectStore(review_store).getAll();\n    }).then(results => {\n      let reviews = results.filter(result => result.offlineFlag == true);\n      reviews.forEach(review => {\n        DBHelper.saveNewReview(review, (error, result) =>{\n          if(error){\n            callback(error, null);\n            return;\n          }\n          callback(null, result);\n        });\n      })\n    }).catch(err => {\n      callback(err,null);\n    })\n  }\n\n  /**\n   * \n   */\n  static networkReconnect(){\n    DBHelper.networkReconnectAddReview();\n  }\n\n  /**\n   * \n   */\n  static updateConnectionStatus() {\n    if((type == 'none') && (connection.effectiveType == 'none')){\n      console.log(\"Connection has been lost\");\n      networkStatus = false;\n    } else {\n      console.log(\"Connection reestablished\");\n      networkStatus = true;\n      //check for pending updates need more code under here\n      DBHelper.networkReconnect();\n    }\n    console.log(\"Connection type changed from \" + type + \" to \" + connection.effectiveType);\n    type = connection.effectiveType;\n  }\n\n  /**\n   * Add new and Update old review\n   */\n  static addUpdateReviewIDB(review) {\n    dbReviews.then(db => {\n      console.log('adding review to idb cache');\n      return db.transaction(review_store, 'readwrite')\n      .objectStore(review_store).put(review, review.id)\n    }).then(function() {\n      console.log('Successfully added ')\n    }).catch(error=> {\n      console.log(`Error adding review to idb cache: ${error}`);\n    })\n  }\n\n  /**\n   * \n   */\n  static saveNewReview(review, callback){\n    const reviewURL = DBHelper.DATABASE_URL_REVIEWS;\n    fetch(reviewURL, {\n      method: 'post',\n      body: JSON.stringify(review)\n    }).then(response => {\n      response.json().then(results => {\n        //call to function to add or update db\n        DBHelper.addUpdateReviewIDB(results);\n        callback(null,results);\n      });\n    }).catch(err => {\n      const error = `Submission to server failed: ${err}`;\n      callback(error,null);\n    })\n  }\n\n  /**\n   * Save Review \n   */\n  static saveReview(id, name, rating, comment,callback) {\n    const review = {\n      restaurant_id: id,\n      name: name,\n      rating: rating,\n      comments: comment,\n      createdAt: Date.now()\n    }\n    //if connection submit to server else post in idb with flag set for offline\n    //DBHelper.checkConnection();\n    if(networkStatus === false){\n      //add flag for offline\n      const tempId = new Date().getTime();\n      review.id = tempId;\n      review.offlineFlag = true;\n      //add review to idb\n      DBHelper.addUpdateReviewIDB(review);\n      return;\n    }\n    DBHelper.saveNewReview(review, (error, result) => {\n      if(error){\n        callback(error, null);\n        return;\n      }\n      callback(null, result);\n    });\n  }\n  /**\n   * Fetch reviews by id for resource management\n   */\n  static fetchReviewByRestaurantId(id, callback){\n      const reviewURL = `${DBHelper.DATABASE_URL_REVIEWS}?restaurant_id=${id}`;\n      console.log(reviewURL);\n      fetch(reviewURL).then(response => {\n        response.json().then(reviews => {\n          if(!reviews){\n            callback(error,null);\n          }else{\n            //deal with reviews that are found...add to idb\n            reviews.forEach(review => {\n              DBHelper.addUpdateReviewIDB(review);\n            }); \n          }\n          callback(null, reviews);\n        });\n      }).catch(err => {\n        console.log(`Review request failed: Returned ${err}`);\n        //need logic to fetch from idb on error and send data back with callback\n        dbReviews.then(db => {\n          return db.transaction(review_store)\n          .objectStore(review_store).getAll();\n        }).then(results => {\n          let final = results.filter(result => result.restaurant_id == id);\n          callback(null, final);\n        }).catch(err => {\n          callback(err,null)\n        })\n      });\n  }\n}\n//add event listener for connection change from mozilla.org\nconnection.addEventListener('change', DBHelper.updateConnectionStatus); \n\n"]}